'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fetch = require('node-fetch');
var promises = require('timers/promises');
var uuid = require('uuid');
var winston = require('winston');
var dedent = require('ts-dedent');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch);
var uuid__namespace = /*#__PURE__*/_interopNamespace(uuid);

const RetoolSDKVersion = '0.0.35';

const AGENT_SERVER_ERROR = 'AgentServerError';
function createAgentServerError(error) {
    if (error instanceof Error) {
        const agentError = {
            name: error.name,
            message: error.message,
            stack: error.stack,
        };
        if ('code' in error) {
            if (typeof error.code === 'number') {
                agentError.code = error.code;
            }
            else if (error.code === 'string') {
                agentError.code = parseInt(error.code, 10);
            }
        }
        if ('details' in error) {
            agentError.details = error.details;
        }
        return agentError;
    }
    if (typeof error === 'string') {
        return {
            name: AGENT_SERVER_ERROR,
            message: error,
        };
    }
    return {
        name: AGENT_SERVER_ERROR,
        message: 'Unknown agent server error',
    };
}
class FunctionNotFoundError extends Error {
    constructor(functionName) {
        super(`Function "${functionName}" not found on remote agent server.`);
        this.name = 'FunctionNotFoundError';
    }
}
class InvalidArgumentsError extends Error {
    constructor(message) {
        super(message);
        this.name = 'InvalidArgumentsError';
    }
}

function pick(obj, keys) {
    const result = {};
    for (const key of keys) {
        if (key in obj) {
            result[key] = obj[key];
        }
    }
    return result;
}
function isRecord(value) {
    return typeof value === 'object' && value !== null && !Array.isArray(value);
}
function isFalsyArgumentValue(value) {
    return value === null || value === undefined || value === '';
}
function isBooleanString(value) {
    if (typeof value === 'string') {
        const lowercaseValue = value.toLowerCase();
        return lowercaseValue === 'true' || lowercaseValue === 'false';
    }
    return false;
}
function isNumberString(value) {
    if (typeof value === 'string') {
        // Use a regular expression to check if the string is a valid number
        return /^-?\d+(\.\d+)?$/.test(value);
    }
    return false;
}
function isClientError(status) {
    return status >= 400 && status < 500;
}

class ArgumentParser {
    constructor(schema) {
        this.schema = schema;
    }
    parse(argsToParse) {
        const parsedArgs = { ...argsToParse };
        const parsedErrors = [];
        for (const argName in this.schema) {
            const argDefinition = this.schema[argName];
            const argValue = argsToParse[argName];
            const falsyArgValue = isFalsyArgumentValue(argValue);
            if (falsyArgValue) {
                if (argDefinition.required) {
                    parsedErrors.push(`Argument "${argName}" is required but missing.`);
                    continue;
                }
            }
            if (!falsyArgValue) {
                if (argDefinition.array) {
                    if (!Array.isArray(argValue)) {
                        parsedErrors.push(`Argument "${argName}" should be an array.`);
                        continue;
                    }
                    const parseValueTypeItems = argValue.map((item) => this.parseValueType(item, argDefinition.type));
                    if (!parseValueTypeItems.every((item) => item.isValidType)) {
                        parsedErrors.push(`Argument "${argName}" should be an array of type "${argDefinition.type}".`);
                    }
                    parsedArgs[argName] = parseValueTypeItems.map((item) => item.parsedValue);
                }
                else {
                    const parsedValueTypeItem = this.parseValueType(argValue, argDefinition.type);
                    if (!parsedValueTypeItem.isValidType) {
                        parsedErrors.push(`Argument "${argName}" should be of type "${argDefinition.type}".`);
                    }
                    parsedArgs[argName] = parsedValueTypeItem.parsedValue;
                }
            }
        }
        return { parsedErrors, parsedArgs };
    }
    parseValueType(value, expectedType) {
        switch (expectedType) {
            case 'string':
                if (typeof value === 'string') {
                    return {
                        isValidType: true,
                        parsedValue: value,
                    };
                }
                return {
                    isValidType: false,
                    parsedValue: value,
                };
            case 'boolean':
                if (typeof value === 'boolean') {
                    return {
                        isValidType: true,
                        parsedValue: value,
                    };
                }
                if (isBooleanString(value)) {
                    return {
                        isValidType: true,
                        parsedValue: value.toLowerCase() === 'true',
                    };
                }
                return {
                    isValidType: false,
                    parsedValue: value,
                };
            case 'number':
                if (typeof value === 'number') {
                    return {
                        isValidType: true,
                        parsedValue: value,
                    };
                }
                if (isNumberString(value)) {
                    return {
                        isValidType: true,
                        parsedValue: parseFloat(value),
                    };
                }
                return {
                    isValidType: false,
                    parsedValue: value,
                };
            case 'json':
                try {
                    const parsedJSONValue = JSON.parse(JSON.stringify(value));
                    return {
                        isValidType: true,
                        parsedValue: parsedJSONValue,
                    };
                }
                catch {
                    return {
                        isValidType: false,
                        parsedValue: value,
                    };
                }
            default:
                const _expectedType = expectedType;
                throw new Error(`Unknown argument type "${_expectedType}".`);
        }
    }
}
function parseFunctionArgs(args, schema) {
    if (!isRecord(args)) {
        throw new Error(`The given arguments are invalid.`);
    }
    const argumentParser = new ArgumentParser(schema);
    const { parsedArgs, parsedErrors } = argumentParser.parse(args);
    if (parsedErrors.length > 0) {
        const invalidArgumentsError = dedent.dedent `
      Invalid parameter(s) found:
      ${parsedErrors.join('\n')}
    `;
        throw new InvalidArgumentsError(invalidArgumentsError);
    }
    return pick(parsedArgs, Object.keys(schema));
}

const logger = winston.createLogger({
    levels: {
        error: 0,
        warn: 1,
        info: 2,
        verbose: 3,
        debug: 4, // log things like sql queries executed by the ORM
    },
    transports: [
        new winston.transports.Console({
            level: 'info',
        }),
    ],
    exitOnError: false,
    silent: process.env.NODE_ENV === 'test',
});
const CONNECTION_ERROR_INITIAL_TIMEOUT_MS = 50;
const MINIMUM_POLLING_INTERVAL_MS = 100;
const CONNECTION_ERROR_RETRY_MAX_MS = 1000 * 60 * 10; // 10 minutes
const POLLING_TIMEOUT_MS = 5 * 1000; // 5 seconds
async function pollingTimeout() {
    await promises.setTimeout(POLLING_TIMEOUT_MS);
    throw new Error(`Polling timeout after ${POLLING_TIMEOUT_MS}ms`);
}
async function loopWithBackoff(pollingIntervalMs, fn) {
    let delayTimeMs = CONNECTION_ERROR_INITIAL_TIMEOUT_MS;
    let lastLoopTime = Date.now();
    while (true) {
        if (logger.transports[0].level === 'debug') {
            const currentTime = Date.now();
            const loopDurationMs = currentTime - lastLoopTime;
            logger.debug(`Loop time: ${loopDurationMs}ms, delay time: ${delayTimeMs}ms, polling interval: ${pollingIntervalMs}ms`);
            lastLoopTime = currentTime;
        }
        try {
            const result = await Promise.race([fn(), pollingTimeout()]);
            if (result && result !== 'continue') {
                return result;
            }
            await promises.setTimeout(pollingIntervalMs);
            delayTimeMs = Math.max(delayTimeMs / 2, CONNECTION_ERROR_INITIAL_TIMEOUT_MS);
        }
        catch (error) {
            logger.error('Error running sdk agent', error);
            await promises.setTimeout(delayTimeMs);
            delayTimeMs *= 2;
            delayTimeMs = Math.min(delayTimeMs, CONNECTION_ERROR_RETRY_MAX_MS);
        }
    }
}
/**
 * Represents the Retool SDK for interacting with Retool functions and contexts.
 */
class RetoolSDK {
    /**
     * Creates an instance of the RetoolSDK class.
     */
    constructor(config) {
        this._functions = {};
        this._apiKey = config.apiToken;
        this._hostUrl = config.host.replace(/\/$/, ''); // Remove trailing / from host
        this._resourceId = config.resourceId;
        this._environmentName = config.environmentName || 'production';
        this._pollingIntervalMs = config.pollingIntervalMs
            ? Math.max(config.pollingIntervalMs, MINIMUM_POLLING_INTERVAL_MS)
            : 1000;
        this._version = config.version || '0.0.1';
        this._agentUuid = config.agentUuid || uuid__namespace.v4();
        if (config.logLevel) {
            logger.transports[0].level = config.logLevel;
        }
        logger.debug({
            apiKey: this._apiKey,
            hostUrl: this._hostUrl,
            resourceId: this._resourceId,
            environmentName: this._environmentName,
            agentUuid: this._agentUuid,
            version: this._version,
            pollingIntervalMs: this._pollingIntervalMs,
        });
    }
    /**
     * Asynchronously starts listening for incoming Retool function invocations.
     */
    async listen() {
        logger.info('Starting sdk agent');
        const registerResult = await loopWithBackoff(this._pollingIntervalMs, () => this._registerAgent());
        if (registerResult === 'done') {
            logger.info('Agent registered');
            logger.info('Starting processing query');
            loopWithBackoff(this._pollingIntervalMs, () => this._fetchQueryAndExecute());
        }
    }
    /**
     * Registers a Retool function with the specified function definition.
     */
    register({ name, args, impl }) {
        this._functions[name] = {
            args,
            impl,
        };
    }
    async executeFunction(functionName, args, context) {
        logger.info(`Executing function: ${functionName}, context: ${context}`);
        if (functionName === '__testConnection__') {
            return { result: this._testConnection(args, context), args: {} };
        }
        const fnSpec = this._functions[functionName];
        if (!fnSpec) {
            throw new FunctionNotFoundError(functionName);
        }
        const parsedArgs = parseFunctionArgs(args, fnSpec.args);
        logger.debug('Parsed args: ', parsedArgs);
        const result = await fnSpec.impl(parsedArgs, context);
        // TODO: consider truncating large arguments
        return { result, args: parsedArgs };
    }
    _testConnection(_args, context) {
        return {
            success: true,
            version: this._version,
            agentUuid: this._agentUuid,
            context,
        };
    }
    async _registerAgent() {
        const functionsMetadata = {};
        for (const functionName in this._functions) {
            functionsMetadata[functionName] = {
                args: this._functions[functionName].args,
            };
        }
        const response = await fetch__default["default"](`${this._hostUrl}/api/v1/retoolsdk/registerAgent`, {
            method: 'POST',
            // TODO: add ApiToken
            headers: {
                Authorization: `Bearer ${this._apiKey}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                resourceId: this._resourceId,
                environmentName: this._environmentName,
                version: this._version,
                agentUuid: this._agentUuid,
                operations: functionsMetadata,
            }),
        });
        if (!response.ok) {
            if (isClientError(response.status)) {
                logger.error(`Error registering agent: ${response.status} ${await response.text()}}`);
                // client error, stop the client
                return 'stop';
            }
            throw new Error(`Error connecting to retool server: ${response.status} ${await response.text()}}`);
        }
        const { versionHash } = await response.json();
        this._versionHash = versionHash;
        logger.info(`Agent registered with versionHash ${versionHash}`);
        return 'done';
    }
    async _fetchQueryAndExecute() {
        const pendingQueryFetch = await fetch__default["default"](`${this._hostUrl}/api/v1/retoolsdk/popQuery`, {
            method: 'POST',
            headers: {
                Authorization: `Bearer ${this._apiKey}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                resourceId: this._resourceId,
                environmentName: this._environmentName,
                agentUuid: this._agentUuid,
                versionHash: this._versionHash,
            }),
        });
        if (!pendingQueryFetch.ok) {
            if (isClientError(pendingQueryFetch.status)) {
                logger.error(`Error fetching query (${pendingQueryFetch.status}): ${await pendingQueryFetch.text()}`);
                return 'stop';
            }
            throw new Error(`Server error when fetching query: ${pendingQueryFetch.status}. Retrying...`);
        }
        const body = await pendingQueryFetch.json();
        if (body.query) {
            logger.debug('execute query', body.query); // This might contain sensitive information
            const agentReceivedQueryAt = new Date().toISOString();
            const queryUuid = body.query.queryUuid;
            const { method, parameters, context } = body.query.queryInfo;
            let status;
            let executionResponse = undefined;
            let executionArgs = undefined;
            let agentError = undefined;
            try {
                const executionResult = await this.executeFunction(method, parameters, context);
                executionResponse = executionResult.result;
                executionArgs = executionResult.args;
                status = 'success';
            }
            catch (err) {
                status = 'error';
                agentError = createAgentServerError(err);
            }
            const agentFinishedQueryAt = new Date().toISOString();
            const updateQueryResponse = await fetch__default["default"](`${this._hostUrl}/api/v1/retoolsdk/postQueryResponse`, {
                method: 'POST',
                headers: {
                    Authorization: `Bearer ${this._apiKey}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    resourceId: this._resourceId,
                    environmentName: this._environmentName,
                    versionHash: this._versionHash,
                    agentUuid: this._agentUuid,
                    queryUuid,
                    status,
                    data: executionResponse,
                    metadata: {
                        agentReceivedQueryAt,
                        agentFinishedQueryAt,
                        parameters: executionArgs,
                    },
                    error: agentError,
                }),
            });
            logger.debug('update query response status: ', updateQueryResponse.status, await updateQueryResponse.text());
        }
        return 'continue';
    }
}

exports.RetoolSDK = RetoolSDK;
exports.RetoolSDKVersion = RetoolSDKVersion;
